---
sidebar_position: 6
title: Gazebo Basics
description: Learn to create robot models, build simulation worlds, and integrate Gazebo with ROS 2
---

# Gazebo Basics

import Callout from '@site/src/components/Callout';
import CodePlayground from '@site/src/components/CodePlayground';
import Quiz from '@site/src/components/Quiz';
import Checkpoint from '@site/src/components/Checkpoint';

## Learning Outcomes

By the end of this chapter, you will be able to:

- **Install and configure Gazebo** for ROS 2 development
- **Create robot models** using URDF/SDF formats
- **Build simulation worlds** with environments and objects
- **Integrate Gazebo with ROS 2** for sensor data and control
- **Run and debug** simulated robots in Gazebo

## Prerequisites

- Chapters 3-5: ROS 2 fundamentals and simulation introduction
- Ubuntu 22.04 with ROS 2 Humble
- Basic understanding of 3D geometry

---

## Introduction

In Chapter 5, we explored why simulation matters and compared platforms. Now it's time to get hands-on with **Gazebo**â€”the most widely-used robotics simulator in the ROS ecosystem.

Gazebo (formerly Gazebo Classic, now Gazebo Fortress/Harmonic) provides everything you need to simulate robots: physics engines, sensor models, 3D rendering, and seamless ROS 2 integration. Whether you're building a mobile robot, manipulator, or drone, Gazebo is likely your starting point.

<Callout type="info" title="What You'll Build">
By the end of this chapter, you'll have created a simulated mobile robot with sensors, integrated it with ROS 2, and controlled it through teleoperation. You'll understand the complete workflow from model creation to simulation execution.
</Callout>

---

## Installation and Setup

### Installing Gazebo for ROS 2

Gazebo integrates tightly with ROS 2. Install the ROS 2 Gazebo packages:

```bash
# Install Gazebo and ROS 2 integration packages
sudo apt update
sudo apt install ros-humble-gazebo-ros-pkgs ros-humble-gazebo-ros2-control

# Install additional tools
sudo apt install ros-humble-ros-gz ros-humble-ros-gz-bridge
```

### Testing Your Installation

Verify Gazebo works with ROS 2:

```bash
# Source ROS 2
source /opt/ros/humble/setup.bash

# Launch Gazebo with ROS 2
ros2 launch gazebo_ros gazebo.launch.py
```

You should see the Gazebo window open with an empty world. Press `Ctrl+C` to close it.

<Callout type="tip" title="Gazebo Versions">
ROS 2 Humble works with Gazebo Fortress (gz-fortress) or Gazebo Harmonic (gz-harmonic). The ROS 2 packages handle version compatibility automatically. Use `gz sim --version` to check your Gazebo version.
</Callout>

---

## Gazebo Architecture

Understanding Gazebo's architecture helps you work effectively with it.

### Key Components

**1. World Files (SDF)**
- Define the simulation environment
- Specify physics engine, lighting, and gravity
- Place models and objects
- Format: Simulation Description Format (SDF)

**2. Model Files (URDF/SDF)**
- Describe robot structure (links and joints)
- Define visual appearance and collision geometry
- Specify inertial properties (mass, inertia)
- Add sensors and actuators

**3. Plugins**
- Extend Gazebo functionality
- Sensor plugins: Publish sensor data to ROS 2
- Actuator plugins: Subscribe to control commands
- Custom plugins: Implement specific behaviors

**4. Physics Engines**
- ODE (default): Fast, stable
- Bullet: Good for complex contacts
- DART: Advanced features
- Simbody: Biomechanics focus

**5. Rendering**
- OGRE 1.x/2.x: Graphics rendering
- Sensors: Camera, depth, lidar visualization

---

## Creating Robot Models with URDF

**URDF** (Unified Robot Description Format) is the standard for describing robots in ROS. Let's build a simple robot.

### URDF Basics

A URDF model consists of:
- **Links**: Rigid bodies (chassis, wheels, sensors)
- **Joints**: Connections between links (fixed, revolute, continuous)
- **Materials**: Visual appearance (colors, textures)

### Simple Robot Example

<CodePlayground language="xml" title="simple_robot.urdf">
{`<?xml version="1.0"?>
<robot name="simple_robot">

  <!-- Base Link (Chassis) -->
  <link name="base_link">
    <visual>
      <geometry>
        <box size="0.6 0.4 0.2"/>
      </geometry>
      <material name="blue">
        <color rgba="0 0 0.8 1"/>
      </material>
    </visual>

    <collision>
      <geometry>
        <box size="0.6 0.4 0.2"/>
      </geometry>
    </collision>

    <inertial>
      <mass value="10.0"/>
      <inertia ixx="0.1" ixy="0.0" ixz="0.0"
               iyy="0.1" iyz="0.0" izz="0.1"/>
    </inertial>
  </link>

  <!-- Left Wheel -->
  <link name="left_wheel">
    <visual>
      <geometry>
        <cylinder radius="0.1" length="0.05"/>
      </geometry>
      <material name="black">
        <color rgba="0 0 0 1"/>
      </material>
    </visual>

    <collision>
      <geometry>
        <cylinder radius="0.1" length="0.05"/>
      </geometry>
    </collision>

    <inertial>
      <mass value="1.0"/>
      <inertia ixx="0.01" ixy="0.0" ixz="0.0"
               iyy="0.01" iyz="0.0" izz="0.01"/>
    </inertial>
  </link>

  <!-- Joint connecting base to left wheel -->
  <joint name="left_wheel_joint" type="continuous">
    <parent link="base_link"/>
    <child link="left_wheel"/>
    <origin xyz="0 0.225 0" rpy="1.57 0 0"/>
    <axis xyz="0 0 1"/>
  </joint>

  <!-- Right Wheel (similar to left) -->
  <link name="right_wheel">
    <visual>
      <geometry>
        <cylinder radius="0.1" length="0.05"/>
      </geometry>
      <material name="black">
        <color rgba="0 0 0 1"/>
      </material>
    </visual>

    <collision>
      <geometry>
        <cylinder radius="0.1" length="0.05"/>
      </geometry>
    </collision>

    <inertial>
      <mass value="1.0"/>
      <inertia ixx="0.01" ixy="0.0" ixz="0.0"
               iyy="0.01" iyz="0.0" izz="0.01"/>
    </inertial>
  </link>

  <joint name="right_wheel_joint" type="continuous">
    <parent link="base_link"/>
    <child link="right_wheel"/>
    <origin xyz="0 -0.225 0" rpy="1.57 0 0"/>
    <axis xyz="0 0 1"/>
  </joint>

</robot>
`}
</CodePlayground>

### Key URDF Concepts

**Visual vs Collision Geometry:**
- **Visual**: What you see (can be complex meshes)
- **Collision**: What physics uses (should be simple for performance)

**Inertial Properties:**
- **Mass**: Weight of the link
- **Inertia**: Resistance to rotation (3x3 matrix)
- Critical for accurate physics simulation

**Joint Types:**
- **Fixed**: No movement
- **Revolute**: Rotation with limits (e.g., elbow)
- **Continuous**: Unlimited rotation (e.g., wheel)
- **Prismatic**: Linear motion (e.g., slider)

<Callout type="warning" title="Common URDF Mistakes">
- Forgetting inertial properties (robot will behave strangely)
- Using complex collision geometry (simulation will be slow)
- Incorrect joint axes (robot will move in wrong directions)
- Missing parent-child relationships (robot will fall apart)
</Callout>

---

## Building Simulation Worlds

Worlds define the environment where your robot operates.

### Basic World File

<CodePlayground language="xml" title="basic_world.sdf">
{`<?xml version="1.0"?>
<sdf version="1.6">
  <world name="basic_world">

    <!-- Physics -->
    <physics type="ode">
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1.0</real_time_factor>
    </physics>

    <!-- Lighting -->
    <light name="sun" type="directional">
      <pose>0 0 10 0 0 0</pose>
      <diffuse>1 1 1 1</diffuse>
      <specular>0.2 0.2 0.2 1</specular>
      <direction>0.5 0.5 -1</direction>
    </light>

    <!-- Ground Plane -->
    <model name="ground_plane">
      <static>true</static>
      <link name="link">
        <collision name="collision">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
            </plane>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
          <material>
            <ambient>0.8 0.8 0.8 1</ambient>
          </material>
        </visual>
      </link>
    </model>

    <!-- Add obstacles -->
    <model name="box_obstacle">
      <pose>2 0 0.5 0 0 0</pose>
      <static>true</static>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>1 1 1</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>1 1 1</size>
            </box>
          </geometry>
          <material>
            <ambient>1 0 0 1</ambient>
          </material>
        </visual>
      </link>
    </model>

  </world>
</sdf>
`}
</CodePlayground>

---

## ROS 2 Integration

The power of Gazebo comes from ROS 2 integration. Let's connect them.

### Gazebo Launch File

<CodePlayground language="python" title="gazebo_robot.launch.py">
{`from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch_ros.actions import Node
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    # Get package directories
    pkg_gazebo_ros = get_package_share_directory('gazebo_ros')

    # Path to robot URDF
    urdf_file = os.path.join(
        get_package_share_directory('my_robot_description'),
        'urdf',
        'simple_robot.urdf'
    )

    # Read URDF file
    with open(urdf_file, 'r') as f:
        robot_desc = f.read()

    # Launch Gazebo
    gazebo = IncludeLaunchDescription(
        PythonLaunchDescriptionSource(
            os.path.join(pkg_gazebo_ros, 'launch', 'gazebo.launch.py')
        )
    )

    # Spawn robot in Gazebo
    spawn_entity = Node(
        package='gazebo_ros',
        executable='spawn_entity.py',
        arguments=[
            '-entity', 'simple_robot',
            '-topic', 'robot_description',
            '-x', '0', '-y', '0', '-z', '0.5'
        ],
        output='screen'
    )

    # Robot state publisher
    robot_state_publisher = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        parameters=[{'robot_description': robot_desc}],
        output='screen'
    )

    return LaunchDescription([
        gazebo,
        robot_state_publisher,
        spawn_entity
    ])
`}
</CodePlayground>

### Running the Simulation

```bash
# Build your workspace
cd ~/ros2_ws
colcon build

# Source the workspace
source install/setup.bash

# Launch Gazebo with your robot
ros2 launch my_robot_gazebo gazebo_robot.launch.py
```

---

## Assessment

<Quiz
  title="Chapter 6 Quiz"
  questions={[
    {
      id: 'q1',
      question: 'What is the difference between visual and collision geometry in URDF?',
      options: [
        'There is no difference',
        'Visual is what you see, collision is what physics uses',
        'Visual is for sensors, collision is for rendering',
        'Collision is always more detailed than visual'
      ],
      correctAnswer: 1,
      explanation: 'Visual geometry is what you see rendered, while collision geometry is what the physics engine uses. Collision should be simpler for performance.'
    },
    {
      id: 'q2',
      question: 'What joint type should you use for a robot wheel?',
      options: [
        'Fixed',
        'Revolute',
        'Continuous',
        'Prismatic'
      ],
      correctAnswer: 2,
      explanation: 'Continuous joints allow unlimited rotation, which is perfect for wheels. Revolute joints have limits and would restrict wheel rotation.'
    },
    {
      id: 'q3',
      question: 'Why are inertial properties important in URDF?',
      options: [
        'They determine visual appearance',
        'They are required for accurate physics simulation',
        'They control sensor data',
        'They are optional and not important'
      ],
      correctAnswer: 1,
      explanation: 'Inertial properties (mass and inertia) are critical for accurate physics simulation. Without them, the robot will behave unrealistically.'
    },
    {
      id: 'q4',
      question: 'What format does Gazebo use for world files?',
      options: [
        'URDF',
        'XML',
        'SDF (Simulation Description Format)',
        'JSON'
      ],
      correctAnswer: 2,
      explanation: 'Gazebo uses SDF (Simulation Description Format) for world files. URDF is used for robot descriptions, though Gazebo can convert URDF to SDF.'
    },
    {
      id: 'q5',
      question: 'How do you spawn a robot in Gazebo from ROS 2?',
      options: [
        'Manually place it in the GUI',
        'Use the spawn_entity.py node',
        'Edit the world file',
        'Use ros2 run gazebo spawn'
      ],
      correctAnswer: 1,
      explanation: 'The spawn_entity.py node from gazebo_ros package is used to spawn robots in Gazebo from ROS 2 launch files.'
    },
    {
      id: 'q6',
      question: 'What should collision geometry prioritize?',
      options: [
        'Visual accuracy',
        'Simplicity for performance',
        'Detailed textures',
        'Complex shapes'
      ],
      correctAnswer: 1,
      explanation: 'Collision geometry should be simple (boxes, cylinders, spheres) for performance. Complex collision geometry slows down physics simulation significantly.'
    }
  ]}
/>

---

## Learning Checkpoint

<Checkpoint
  title="Chapter 6 Mastery Checklist"
  items={[
    { id: 'install', text: 'I can install and configure Gazebo for ROS 2' },
    { id: 'urdf', text: 'I can create robot models using URDF' },
    { id: 'worlds', text: 'I can build simulation worlds with SDF' },
    { id: 'integrate', text: 'I can integrate Gazebo with ROS 2 using launch files' },
    { id: 'run', text: 'I can run and debug simulated robots in Gazebo' },
    { id: 'sensors', text: 'I understand how to add sensors to robot models' }
  ]}
  storageKey="chapter-06-checkpoint"
/>

---

## Summary

**Key Takeaways:**

- **Gazebo** is the standard robotics simulator for ROS 2 with native integration
- **URDF** describes robot structure with links, joints, and properties
- **Visual vs collision** geometry: visual for rendering, collision for physics
- **Inertial properties** are critical for accurate physics simulation
- **SDF world files** define simulation environments
- **ROS 2 integration** uses launch files and gazebo_ros packages

**Best Practices:**
- Keep collision geometry simple for performance
- Always specify inertial properties
- Test models incrementally (add complexity gradually)
- Use robot_state_publisher for joint state visualization

---

## What's Next?

In **Chapter 7: NVIDIA Isaac Sim**, we'll explore:
- Photorealistic simulation with ray tracing
- AI-powered synthetic data generation
- Advanced physics with PhysX 5
- Digital Twin capabilities
- Integration with ROS 2

You'll see how Isaac Sim complements Gazebo for AI-focused robotics applications.

---

## References

Koenig, N., & Howard, A. (2004). Design and use paradigms for Gazebo, an open-source multi-robot simulator. In *2004 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)*.

Open Robotics. (2023). *Gazebo Documentation*. Retrieved from https://gazebosim.org/docs

Open Robotics. (2023). *URDF Tutorials*. Retrieved from http://wiki.ros.org/urdf/Tutorials
